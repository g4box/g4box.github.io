<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>G4Brix • Particelle 3D</title>
  <style>
    :root{
      --bg1:#a9d7ff; --bg2:#d9f1ff;
      --panel:rgba(255,255,255,.78);
      --text:#0b2a3a; --muted:#2a5d76;
      --border:rgba(0,0,0,.08);
      --shadow: 0 10px 30px rgba(0,0,0,.12);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --ui: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    html,body{height:100%; margin:0; font-family:var(--ui); color:var(--text); overflow:hidden;}
    body{
      background: radial-gradient(1200px 600px at 20% 10%, var(--bg2), transparent 60%),
                  linear-gradient(160deg, var(--bg1), var(--bg2));
    }
    canvas{position:fixed; inset:0; width:100%; height:100%; display:block;}
    .panel{
      position:fixed; top:14px; left:14px;
      width:min(380px, calc(100% - 28px));
      background:var(--panel);
      backdrop-filter: blur(6px);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:12px 12px 10px;
      user-select:none;
    }
    .title{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:6px;}
    .title h1{font-size:14px; margin:0; letter-spacing:.2px;}
    .badge{font-family:var(--mono); font-size:11px; padding:2px 8px; border:1px solid var(--border); border-radius:999px;}
    .row{display:flex; align-items:center; justify-content:space-between; gap:10px; margin:7px 0;}
    .row label{font-size:13px; color:var(--muted); flex:1;}
    .row input[type="range"]{flex:1.2}
    .row input[type="color"]{width:42px; height:28px; padding:0; border:none; background:transparent;}
    .row .val{font-family:var(--mono); font-size:12px; width:56px; text-align:right; color:var(--text);}
    .btns{display:flex; gap:8px; margin-top:8px; flex-wrap:wrap;}
    button{
      border:1px solid var(--border);
      background:white;
      border-radius:10px;
      padding:7px 10px;
      font-size:13px;
      cursor:pointer;
      box-shadow: 0 3px 10px rgba(0,0,0,.06);
    }
    button:active{transform: translateY(1px);}
    .small{font-size:12px; color:var(--muted); margin-top:6px; line-height:1.25;}
    .kbd{font-family:var(--mono); font-size:11px; padding:1px 6px; border:1px solid var(--border); border-radius:6px; background:rgba(255,255,255,.7);}
    .footer{
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      margin-top:8px; padding-top:8px; border-top:1px solid var(--border);
      font-size:12px; color:var(--muted);
    }
    a{color:#0b4d6b; text-decoration:none}
    a:hover{text-decoration:underline}
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="panel">
  <div class="title">
    <h1>G4Brix • Particelle 3D / Legami</h1>
    <span class="badge" id="fps">fps: --</span>
  </div>

  <div class="row">
    <label for="count">Particelle</label>
    <input id="count" type="range" min="120" max="2000" step="20" value="700">
    <div class="val" id="countV">700</div>
  </div>

  <div class="row">
    <label for="speed">Velocità</label>
    <input id="speed" type="range" min="0.2" max="2.8" step="0.05" value="1.0">
    <div class="val" id="speedV">1.00</div>
  </div>

  <div class="row">
    <label for="linkDist">Distanza legami</label>
    <input id="linkDist" type="range" min="40" max="220" step="2" value="120">
    <div class="val" id="linkDistV">120</div>
  </div>

  <div class="row">
    <label for="maxLinks">Max legami / particella</label>
    <input id="maxLinks" type="range" min="0" max="14" step="1" value="5">
    <div class="val" id="maxLinksV">5</div>
  </div>

  <div class="row">
    <label for="mergeRate">Fusione (prob.)</label>
    <input id="mergeRate" type="range" min="0" max="0.30" step="0.01" value="0.06">
    <div class="val" id="mergeRateV">0.06</div>
  </div>

  <div class="row">
    <label for="maxComplex">Compl. max</label>
    <input id="maxComplex" type="range" min="1" max="12" step="1" value="7">
    <div class="val" id="maxComplexV">7</div>
  </div>

  <div class="row">
    <label for="depth">Profondità (Z)</label>
    <input id="depth" type="range" min="400" max="2400" step="50" value="1200">
    <div class="val" id="depthV">1200</div>
  </div>

  <div class="row">
    <label for="fov">FOV</label>
    <input id="fov" type="range" min="240" max="900" step="10" value="520">
    <div class="val" id="fovV">520</div>
  </div>

  <div class="row">
    <label for="pColor">Colore base</label>
    <input id="pColor" type="color" value="#1b74b5">
    <div class="val">&nbsp;</div>
  </div>

  <div class="row">
    <label for="bgBoost">Glow / scia</label>
    <input id="bgBoost" type="range" min="0" max="1" step="0.05" value="0.35">
    <div class="val" id="bgBoostV">0.35</div>
  </div>

  <div class="row">
    <label for="fpsCap">Cap FPS</label>
    <input id="fpsCap" type="range" min="20" max="60" step="5" value="45">
    <div class="val" id="fpsCapV">45</div>
  </div>

  <div class="row">
    <label><input id="lowPower" type="checkbox" checked> Low power</label>
    <div class="val">&nbsp;</div>
  </div>

  <div class="btns">
    <button id="reset">Reset</button>
    <button id="pause">Pausa</button>
  </div>

  <div class="small">
    Muovi il mouse = ruota la visuale 3D.<br>
    Tasti: <span class="kbd">Space</span> pausa • <span class="kbd">R</span> reset
  </div>

  <div class="footer">
    <span id="stats">--</span>
    <span><a href="https://g4brix.infy.uk" target="_blank" rel="noopener">g4brix.infy.uk</a></span>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });
  let W=0,H=0,DPR=1;
  function resize(){
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = innerWidth|0; H = innerHeight|0;
    canvas.width  = (W*DPR)|0;
    canvas.height = (H*DPR)|0;
    canvas.style.width = W+"px";
    canvas.style.height = H+"px";
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  const $ = s => document.querySelector(s);
  const ui = {
    count:$('#count'), speed:$('#speed'), linkDist:$('#linkDist'), maxLinks:$('#maxLinks'),
    mergeRate:$('#mergeRate'), maxComplex:$('#maxComplex'),
    depth:$('#depth'), fov:$('#fov'),
    pColor:$('#pColor'), bgBoost:$('#bgBoost'),
    fpsCap:$('#fpsCap'), lowPower:$('#lowPower'),
    reset:$('#reset'), pause:$('#pause'),
    fps:$('#fps'), stats:$('#stats'),
    countV:$('#countV'), speedV:$('#speedV'), linkDistV:$('#linkDistV'), maxLinksV:$('#maxLinksV'),
    mergeRateV:$('#mergeRateV'), maxComplexV:$('#maxComplexV'),
    depthV:$('#depthV'), fovV:$('#fovV'),
    bgBoostV:$('#bgBoostV'), fpsCapV:$('#fpsCapV')
  };
  function bindRange(el, out, fmt=v=>v){
    const f=()=>out.textContent = fmt(el.value);
    el.addEventListener('input', f, {passive:true}); f();
  }
  bindRange(ui.count, ui.countV, v=>String(v));
  bindRange(ui.speed, ui.speedV, v=>(+v).toFixed(2));
  bindRange(ui.linkDist, ui.linkDistV, v=>String(v));
  bindRange(ui.maxLinks, ui.maxLinksV, v=>String(v));
  bindRange(ui.mergeRate, ui.mergeRateV, v=>(+v).toFixed(2));
  bindRange(ui.maxComplex, ui.maxComplexV, v=>String(v));
  bindRange(ui.depth, ui.depthV, v=>String(v));
  bindRange(ui.fov, ui.fovV, v=>String(v));
  bindRange(ui.bgBoost, ui.bgBoostV, v=>(+v).toFixed(2));
  bindRange(ui.fpsCap, ui.fpsCapV, v=>String(v));

  const P = {
    count:+ui.count.value,
    speed:+ui.speed.value,
    linkDist:+ui.linkDist.value,
    maxLinks:+ui.maxLinks.value,
    mergeRate:+ui.mergeRate.value,
    maxComplex:+ui.maxComplex.value,
    depth:+ui.depth.value,
    fov:+ui.fov.value,
    baseColor:ui.pColor.value,
    bgBoost:+ui.bgBoost.value,
    fpsCap:+ui.fpsCap.value,
    lowPower:ui.lowPower.checked
  };

  ui.count.addEventListener('input', ()=>{P.count=+ui.count.value; syncCount();},{passive:true});
  ui.speed.addEventListener('input', ()=>P.speed=+ui.speed.value,{passive:true});
  ui.linkDist.addEventListener('input', ()=>{P.linkDist=+ui.linkDist.value; rebuildGrid();},{passive:true});
  ui.maxLinks.addEventListener('input', ()=>P.maxLinks=+ui.maxLinks.value,{passive:true});
  ui.mergeRate.addEventListener('input', ()=>P.mergeRate=+ui.mergeRate.value,{passive:true});
  ui.maxComplex.addEventListener('input', ()=>P.maxComplex=+ui.maxComplex.value,{passive:true});
  ui.depth.addEventListener('input', ()=>{P.depth=+ui.depth.value; rebuildGrid();},{passive:true});
  ui.fov.addEventListener('input', ()=>P.fov=+ui.fov.value,{passive:true});
  ui.pColor.addEventListener('input', ()=>P.baseColor=ui.pColor.value,{passive:true});
  ui.bgBoost.addEventListener('input', ()=>P.bgBoost=+ui.bgBoost.value,{passive:true});
  ui.fpsCap.addEventListener('input', ()=>P.fpsCap=+ui.fpsCap.value,{passive:true});
  ui.lowPower.addEventListener('change', ()=>P.lowPower=ui.lowPower.checked,{passive:true});

  // ===== PRNG (xorshift32) =====
  let seed = 0;
  function rnd(){
    seed ^= seed<<13; seed ^= seed>>>17; seed ^= seed<<5;
    return ((seed>>>0) / 4294967296);
  }

  class Particle{
    constructor(x,y,z,vx,vy,vz,c=1){
      this.x=x; this.y=y; this.z=z;
      this.vx=vx; this.vy=vy; this.vz=vz;
      this.c=c;
      this.r=1.2 + Math.sqrt(c)*1.2;
      this.linked=0;
      this.h=rnd();
    }
    recalc(){ this.r=1.2 + Math.sqrt(this.c)*1.2; }
  }

  let particles=[];
  function init(){
    particles=[];
    seed = (Date.now() ^ 0x9e3779b9)>>>0;
    const n=P.count|0;
    const halfZ = P.depth*0.5;
    for(let i=0;i<n;i++){
      const x=(rnd()-0.5)*W;
      const y=(rnd()-0.5)*H;
      const z=(rnd()-0.5)*P.depth;
      const a=rnd()*Math.PI*2;
      const b=(rnd()-0.5)*0.7;
      const sp=0.35 + rnd()*0.9;
      const vx=Math.cos(a)*sp, vy=Math.sin(a)*sp, vz=b*sp;
      particles.push(new Particle(x,y,z,vx,vy,vz,1));
    }
  }
  init();

  function syncCount(){
    const target=P.count|0;
    const cur=particles.length;
    if(cur<target){
      const add=Math.min(250, target-cur);
      for(let i=0;i<add;i++){
        const x=(rnd()-0.5)*W;
        const y=(rnd()-0.5)*H;
        const z=(rnd()-0.5)*P.depth;
        const a=rnd()*Math.PI*2;
        const b=(rnd()-0.5)*0.7;
        const sp=0.35 + rnd()*0.9;
        particles.push(new Particle(x,y,z,Math.cos(a)*sp,Math.sin(a)*sp,b*sp,1));
      }
    }else if(cur>target){
      particles.length=target;
    }
  }

  // ===== Camera (mouse rotates yaw/pitch) =====
  let yaw=0, pitch=0;
  let targetYaw=0, targetPitch=0;
  let mx=0,my=0;
  addEventListener('pointermove', (e)=>{
    mx = (e.clientX / W - 0.5);
    my = (e.clientY / H - 0.5);
    targetYaw = mx * 1.2;        // left-right
    targetPitch = -my * 0.9;     // up-down
  }, {passive:true});

  function rotY(x,z,a){ // yaw
    const ca=Math.cos(a), sa=Math.sin(a);
    return { x: x*ca + z*sa, z: -x*sa + z*ca };
  }
  function rotX(y,z,a){ // pitch
    const ca=Math.cos(a), sa=Math.sin(a);
    return { y: y*ca - z*sa, z: y*sa + z*ca };
  }

  // ===== Spatial grid in 3D (cheap: bucket on x,y,z) =====
  let cell=140, cols=1, rows=1, deps=1, grid=[];
  function rebuildGrid(){
    // cell size driven by linkDist but not too small
    cell = Math.max(70, Math.min(220, P.linkDist|0));
    cols = Math.max(1, Math.ceil(W / cell));
    rows = Math.max(1, Math.ceil(H / cell));
    deps = Math.max(1, Math.ceil(P.depth / cell));
    grid = new Array(cols*rows*deps);
    for(let i=0;i<grid.length;i++) grid[i]=[];
  }
  rebuildGrid();
  addEventListener('resize', rebuildGrid, {passive:true});

  function idx3(x,y,z){
    // map space centered at 0 to [0..]
    const cx = Math.max(0, Math.min(cols-1, ((x + W*0.5) / cell) | 0));
    const cy = Math.max(0, Math.min(rows-1, ((y + H*0.5) / cell) | 0));
    const cz = Math.max(0, Math.min(deps-1, ((z + P.depth*0.5) / cell) | 0));
    return (cz*rows + cy)*cols + cx;
  }
  function clearGrid(){ for(let i=0;i<grid.length;i++) grid[i].length=0; }

  // ===== Color helper =====
  function hexToRgb(hex){
    const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if(!m) return {r:27,g:116,b:181};
    return {r:parseInt(m[1],16), g:parseInt(m[2],16), b:parseInt(m[3],16)};
  }
  const mix=(a,b,t)=>a+(b-a)*t;

  // ===== Controls =====
  let paused=false;
  ui.pause.addEventListener('click', ()=>togglePause(), {passive:true});
  ui.reset.addEventListener('click', ()=>init(), {passive:true});
  addEventListener('keydown', (e)=>{
    if(e.code==="Space"){ e.preventDefault(); togglePause(); }
    if(e.key==="r"||e.key==="R"){ init(); }
  });
  function togglePause(){
    paused=!paused;
    ui.pause.textContent = paused ? "Riprendi" : "Pausa";
  }

  // ===== Loop (FPS cap) =====
  let last=performance.now(), acc=0, frames=0, fps=0, fpsLast=performance.now();

  requestAnimationFrame(function loop(now){
    requestAnimationFrame(loop);

    const cap=Math.max(10, P.fpsCap|0);
    const step=1000/cap;
    const dt=now-last; last=now;
    if(paused){ draw(0); return; }

    acc += dt;
    if(acc < step) return;
    const simDt = Math.min(33, acc);
    acc = 0;

    update(simDt/16.6667);
    draw(simDt/16.6667);

    frames++;
    if(now - fpsLast > 700){
      fps = Math.round(frames*1000/(now-fpsLast));
      frames=0; fpsLast=now;
      ui.fps.textContent = `fps: ${fps}`;
    }
  });

  function update(tMul){
    syncCount();

    // smooth camera movement (avoid jitter)
    yaw += (targetYaw - yaw) * 0.08;
    pitch += (targetPitch - pitch) * 0.08;

    const spMul=P.speed;
    const lp=P.lowPower;
    const damp = lp ? 0.998 : 0.9992;

    const halfW=W*0.5, halfH=H*0.5, halfZ=P.depth*0.5;

    for(const p of particles){
      p.vx *= damp; p.vy *= damp; p.vz *= damp;
      p.x += p.vx*spMul*tMul;
      p.y += p.vy*spMul*tMul;
      p.z += p.vz*spMul*tMul;

      // bounce in 3D box
      const r=p.r;
      if(p.x < -halfW+r){ p.x = -halfW+r; p.vx = Math.abs(p.vx); }
      else if(p.x > halfW-r){ p.x = halfW-r; p.vx = -Math.abs(p.vx); }

      if(p.y < -halfH+r){ p.y = -halfH+r; p.vy = Math.abs(p.vy); }
      else if(p.y > halfH-r){ p.y = halfH-r; p.vy = -Math.abs(p.vy); }

      if(p.z < -halfZ+r){ p.z = -halfZ+r; p.vz = Math.abs(p.vz); }
      else if(p.z > halfZ-r){ p.z = halfZ-r; p.vz = -Math.abs(p.vz); }

      p.linked=0;
    }

    clearGrid();
    for(let i=0;i<particles.length;i++){
      grid[idx3(particles[i].x, particles[i].y, particles[i].z)].push(i);
    }

    const dist=P.linkDist, dist2=dist*dist;
    const mergeDist=Math.max(8, dist*0.16), mergeDist2=mergeDist*mergeDist;

    let checksBudget = lp ? Math.min(320000, particles.length*420) : 1e9;
    let merges=0;

    const toRemove=new Set();
    const toAdd=[];

    for(let i=0;i<particles.length;i++){
      if(checksBudget<=0) break;
      if(toRemove.has(i)) continue;
      const a=particles[i];

      const cx = ((a.x + halfW) / cell) | 0;
      const cy = ((a.y + halfH) / cell) | 0;
      const cz = ((a.z + halfZ) / cell) | 0;

      for(let oz=-1; oz<=1; oz++){
        const zz=cz+oz; if(zz<0||zz>=deps) continue;
        for(let oy=-1; oy<=1; oy++){
          const yy=cy+oy; if(yy<0||yy>=rows) continue;
          for(let ox=-1; ox<=1; ox++){
            const xx=cx+ox; if(xx<0||xx>=cols) continue;

            const cellList = grid[(zz*rows + yy)*cols + xx];
            for(let k=0;k<cellList.length;k++){
              const j=cellList[k];
              if(j<=i) continue;
              if(checksBudget--<=0) break;
              if(toRemove.has(j)) continue;

              const b=particles[j];
              const dx=b.x-a.x, dy=b.y-a.y, dz=b.z-a.z;
              const d2=dx*dx+dy*dy+dz*dz;

              // merge
              if(d2 < mergeDist2 && merges < 140){
                const maxC=P.maxComplex|0;
                if(a.c < maxC || b.c < maxC){
                  const baseProb=P.mergeRate;
                  const cBias = 1 / (1 + 0.35*(a.c+b.c));
                  const prob = baseProb * cBias;
                  if(rnd() < prob){
                    const nx=(a.x+b.x)*0.5, ny=(a.y+b.y)*0.5, nz=(a.z+b.z)*0.5;
                    const nvx=(a.vx+b.vx)*0.5 + (rnd()-0.5)*0.18;
                    const nvy=(a.vy+b.vy)*0.5 + (rnd()-0.5)*0.18;
                    const nvz=(a.vz+b.vz)*0.5 + (rnd()-0.5)*0.18;
                    const nc=Math.min(maxC, a.c+b.c);
                    const np=new Particle(nx,ny,nz,nvx,nvy,nvz,nc);
                    np.h = (a.h*0.5 + b.h*0.5 + (rnd()-0.5)*0.08 + 1) % 1;

                    toRemove.add(i); toRemove.add(j);
                    toAdd.push(np);
                    merges++;
                    break;
                  }
                }
              }

              // link count (for rendering intensity)
              const canLink = (P.maxLinks>0 && a.linked < P.maxLinks && b.linked < P.maxLinks);
              if(canLink && d2 < dist2){
                a.linked++; b.linked++;
              }
            }
          }
        }
      }
    }

    if(toRemove.size){
      const next=[];
      for(let i=0;i<particles.length;i++) if(!toRemove.has(i)) next.push(particles[i]);
      for(const p of toAdd) next.push(p);
      particles=next;
    }

    ui.stats.textContent = `p: ${particles.length} • merge: ${merges}`;
  }

  function draw(tMul){
    // soft clear (trail)
    ctx.fillStyle = `rgba(255,255,255,${0.08 + 0.06*P.bgBoost})`;
    ctx.fillRect(0,0,W,H);

    const base = hexToRgb(P.baseColor);
    const halfW=W*0.5, halfH=H*0.5;

    // Project all points first (so we can depth-sort cheaply)
    const projected = new Array(particles.length);
    for(let i=0;i<particles.length;i++){
      const p=particles[i];

      // rotate camera around origin (yaw then pitch)
      let rx=p.x, ry=p.y, rz=p.z;
      const ryaw = rotY(rx, rz, yaw); rx=ryaw.x; rz=ryaw.z;
      const rpitch = rotX(ry, rz, pitch); ry=rpitch.y; rz=rpitch.z;

      // push forward so z is mostly positive for perspective
      const zCam = rz + P.depth*0.75;
      const scale = P.fov / Math.max(50, zCam);
      const sx = rx*scale + halfW;
      const sy = ry*scale + halfH;

      projected[i] = { i, sx, sy, zCam, scale };
    }

    // Build grid again for link drawing (use original 3D positions for neighbors; cheap enough)
    clearGrid();
    for(let i=0;i<particles.length;i++){
      const p=particles[i];
      grid[idx3(p.x,p.y,p.z)].push(i);
    }

    // Links (budget)
    const dist=P.linkDist, dist2=dist*dist;
    const lp=P.lowPower;
    let linkBudget = lp ? Math.min(16000, particles.length*14) : 38000;

    ctx.lineWidth = 1;

    for(let i=0;i<particles.length;i++){
      if(linkBudget<=0) break;
      const a=particles[i];
      const pa=projected[i];

      const cx = ((a.x + halfW) / cell) | 0;
      const cy = ((a.y + halfH) / cell) | 0;
      const cz = ((a.z + P.depth*0.5) / cell) | 0;

      for(let oz=-1; oz<=1; oz++){
        const zz=cz+oz; if(zz<0||zz>=deps) continue;
        for(let oy=-1; oy<=1; oy++){
          const yy=cy+oy; if(yy<0||yy>=rows) continue;
          for(let ox=-1; ox<=1; ox++){
            const xx=cx+ox; if(xx<0||xx>=cols) continue;

            const list = grid[(zz*rows + yy)*cols + xx];
            for(let k=0;k<list.length;k++){
              const j=list[k];
              if(j<=i) continue;

              const b=particles[j];
              const dx=b.x-a.x, dy=b.y-a.y, dz=b.z-a.z;
              const d2=dx*dx+dy*dy+dz*dz;

              if(d2 < dist2){
                if(linkBudget--<=0) break;

                const pb=projected[j];
                // skip off-screen fast
                if((pa.sx< -50 && pb.sx< -50) || (pa.sx>W+50 && pb.sx>W+50) ||
                   (pa.sy< -50 && pb.sy< -50) || (pa.sy>H+50 && pb.sy>H+50)) continue;

                const d=Math.sqrt(d2);
                const t=1-(d/dist);

                // fade with distance + depth
                const depthFade = Math.max(0.15, Math.min(1, 900 / (0.5*(pa.zCam+pb.zCam))));
                const alpha = (0.06 + 0.24*t) * (0.55 + 0.45*P.bgBoost) * depthFade;

                const r = Math.round(mix(base.r,255,0.10+0.10*t));
                const g = Math.round(mix(base.g,255,0.08+0.08*t));
                const bb = Math.round(mix(base.b,255,0.10+0.10*t));

                ctx.strokeStyle = `rgba(${r},${g},${bb},${alpha})`;
                ctx.beginPath();
                ctx.moveTo(pa.sx, pa.sy);
                ctx.lineTo(pb.sx, pb.sy);
                ctx.stroke();
              }
            }
          }
        }
      }
    }

    // Draw particles sorted by depth (back to front)
    projected.sort((a,b)=> b.zCam - a.zCam);

    for(const pr of projected){
      const p=particles[pr.i];

      // size shrinks with distance
      const radius = p.r * pr.scale * 1.2;
      if(radius < 0.15) continue;

      const cT = (p.c-1) / Math.max(1, (P.maxComplex-1));
      const alpha = (0.35 + 0.35*P.bgBoost) * Math.max(0.15, Math.min(1, 900/pr.zCam));

      const rr=Math.round(mix(base.r,255,0.12+0.30*cT));
      const gg=Math.round(mix(base.g,255,0.08+0.18*cT));
      const bb=Math.round(mix(base.b,255,0.12+0.28*cT));

      ctx.fillStyle = `rgba(${rr},${gg},${bb},${alpha})`;
      ctx.beginPath();
      ctx.arc(pr.sx, pr.sy, radius, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function rotY(x,z,a){
    const ca=Math.cos(a), sa=Math.sin(a);
    return { x: x*ca + z*sa, z: -x*sa + z*ca };
  }
  function rotX(y,z,a){
    const ca=Math.cos(a), sa=Math.sin(a);
    return { y: y*ca - z*sa, z: y*sa + z*ca };
  }
})();
</script>
</body>
</html>
