<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GABRIX • Idee & Progetti</title>
  <style>
    :root{
      --bg1:#a9d7ff; --bg2:#d9f1ff;
      --text:#0b2a3a; --muted:#2a5d76;
      --brand:#0b5fd8;
      --glass:rgba(255,255,255,.70);
      --border:rgba(0,0,0,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.12);
      --radius: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --ui: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    html,body{height:100%; margin:0; font-family:var(--ui); color:var(--text); overflow:hidden;}
    body{
      background: radial-gradient(1200px 600px at 20% 10%, var(--bg2), transparent 60%),
                  linear-gradient(160deg, var(--bg1), var(--bg2));
    }
    canvas{position:fixed; inset:0; width:100%; height:100%; display:block;}

    /* ===== Top overlay ===== */
    .hero{
      position:fixed;
      top:18px; left:18px;
      padding:14px 16px 12px;
      background: var(--glass);
      backdrop-filter: blur(7px);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      max-width:min(560px, calc(100% - 36px));
      user-select:none;
    }
    .brand{
      font-weight: 900;
      letter-spacing: 1px;
      color: var(--brand);
      font-size: 34px;
      line-height: 1;
      margin: 0;
    }
    .tagline{
      margin: 8px 0 0;
      font-size: 13.5px;
      color: var(--muted);
      line-height: 1.35;
    }
    .hint{
      margin-top:10px;
      font-size: 12px;
      color: var(--muted);
    }
    .kbd{
      font-family:var(--mono);
      font-size:11px;
      padding:1px 6px;
      border:1px solid var(--border);
      border-radius:6px;
      background:rgba(255,255,255,.75);
    }

    /* ===== Bottom nav ===== */
    .nav{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:16px;
      width:min(820px, calc(100% - 32px));
      display:flex;
      gap:10px;
      justify-content:space-between;
      padding:10px 12px;
      background: var(--glass);
      backdrop-filter: blur(7px);
      border: 1px solid var(--border);
      border-radius: 999px;
      box-shadow: var(--shadow);
      user-select:none;
    }
    .nav a{
      flex:1;
      text-align:center;
      text-decoration:none;
      color:#0b3e57;
      font-weight:600;
      font-size:13px;
      padding:8px 10px;
      border-radius: 999px;
      transition: background .15s ease, transform .06s ease;
      white-space:nowrap;
    }
    .nav a:hover{ background: rgba(11,95,216,.12); }
    .nav a:active{ transform: translateY(1px); }
    .nav a.primary{
      color:#fff;
      background: rgba(11,95,216,.88);
    }
    .nav a.primary:hover{ background: rgba(11,95,216,.95); }

    /* Small stats (optional) */
    .badge{
      position:fixed;
      top:18px;
      right:18px;
      padding:8px 10px;
      background: var(--glass);
      backdrop-filter: blur(7px);
      border: 1px solid var(--border);
      border-radius: 999px;
      box-shadow: var(--shadow);
      font-family:var(--mono);
      font-size:12px;
      color:#0b2a3a;
      user-select:none;
    }

    @media (max-width:520px){
      .brand{ font-size: 28px; }
      .nav{ gap:6px; padding:8px 10px; }
      .nav a{ font-size:12px; padding:7px 8px; }
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="hero">
  <h1 class="brand">GABRIX</h1>
  <p class="tagline">
    Laboratorio personale di progetti, idee e sperimentazioni: elettronica, domotica, reti, stampa 3D e un po’ di “AI applicata”.
    Roba concreta, testata e migliorata passo-passo.
  </p>
  <div class="hint">
    Muovi il mouse per ruotare la visuale 3D • <span class="kbd">Space</span> pausa • <span class="kbd">R</span> reset
  </div>
</div>

<div class="badge" id="fps">fps: --</div>

<nav class="nav" aria-label="Navigazione">
  <a class="primary" href="index.html">Home</a>
  <a href="projects.html">Progetti</a>
  <a href="experiments.html">Esperimenti</a>
  <a href="blog.html">Appunti</a>
  <a href="contacts.html">Contatti</a>
</nav>

<script>
(() => {
  // ===== Canvas =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });
  const fpsEl = document.getElementById('fps');

  let W=0,H=0,DPR=1;
  function resize(){
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = innerWidth|0; H = innerHeight|0;
    canvas.width  = (W*DPR)|0;
    canvas.height = (H*DPR)|0;
    canvas.style.width = W+"px";
    canvas.style.height = H+"px";
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // ===== Params (light) =====
  const P = {
    count: 780,
    speed: 1.0,
    linkDist: 120,
    maxLinks: 5,
    mergeRate: 0.06,
    maxComplex: 7,
    depth: 1200,
    fov: 520,
    trail: 0.35,      // 0..1
    fpsCap: 45,
    lowPower: true
  };

  // ===== PRNG =====
  let seed = (Date.now() ^ 0x9e3779b9)>>>0;
  function rnd(){
    seed ^= seed<<13; seed ^= seed>>>17; seed ^= seed<<5;
    return ((seed>>>0) / 4294967296);
  }

  class Particle{
    constructor(x,y,z,vx,vy,vz,c=1){
      this.x=x; this.y=y; this.z=z;
      this.vx=vx; this.vy=vy; this.vz=vz;
      this.c=c;
      this.r=1.2 + Math.sqrt(c)*1.2;
      this.linked=0;
      this.h=rnd();
    }
  }

  let particles=[];
  function init(){
    particles=[];
    seed = (Date.now() ^ 0x9e3779b9)>>>0;
    const n=P.count|0;
    const halfZ = P.depth*0.5;
    for(let i=0;i<n;i++){
      const x=(rnd()-0.5)*W;
      const y=(rnd()-0.5)*H;
      const z=(rnd()-0.5)*P.depth;
      const a=rnd()*Math.PI*2;
      const b=(rnd()-0.5)*0.7;
      const sp=0.35 + rnd()*0.9;
      particles.push(new Particle(x,y,z,Math.cos(a)*sp,Math.sin(a)*sp,b*sp,1));
    }
  }
  init();

  // ===== Camera (mouse rotates) =====
  let yaw=0, pitch=0, targetYaw=0, targetPitch=0;
  addEventListener('pointermove', (e)=>{
    const mx = (e.clientX / W - 0.5);
    const my = (e.clientY / H - 0.5);
    targetYaw   = mx * 1.2;
    targetPitch = -my * 0.9;
  }, {passive:true});

  function rotY(x,z,a){
    const ca=Math.cos(a), sa=Math.sin(a);
    return { x: x*ca + z*sa, z: -x*sa + z*ca };
  }
  function rotX(y,z,a){
    const ca=Math.cos(a), sa=Math.sin(a);
    return { y: y*ca - z*sa, z: y*sa + z*ca };
  }

  // ===== 3D grid buckets =====
  let cell=140, cols=1, rows=1, deps=1, grid=[];
  function rebuildGrid(){
    cell = Math.max(70, Math.min(220, P.linkDist|0));
    cols = Math.max(1, Math.ceil(W / cell));
    rows = Math.max(1, Math.ceil(H / cell));
    deps = Math.max(1, Math.ceil(P.depth / cell));
    grid = new Array(cols*rows*deps);
    for(let i=0;i<grid.length;i++) grid[i]=[];
  }
  rebuildGrid();
  addEventListener('resize', rebuildGrid, {passive:true});

  function idx3(x,y,z){
    const cx = Math.max(0, Math.min(cols-1, ((x + W*0.5) / cell) | 0));
    const cy = Math.max(0, Math.min(rows-1, ((y + H*0.5) / cell) | 0));
    const cz = Math.max(0, Math.min(deps-1, ((z + P.depth*0.5) / cell) | 0));
    return (cz*rows + cy)*cols + cx;
  }
  function clearGrid(){ for(let i=0;i<grid.length;i++) grid[i].length=0; }

  // ===== Controls =====
  let paused=false;
  addEventListener('keydown', (e)=>{
    if(e.code==="Space"){ e.preventDefault(); paused=!paused; }
    if(e.key==="r"||e.key==="R"){ init(); }
  });

  // ===== Loop (FPS cap) =====
  let last=performance.now(), acc=0, frames=0, fps=0, fpsLast=performance.now();
  requestAnimationFrame(function loop(now){
    requestAnimationFrame(loop);

    const cap=Math.max(10, P.fpsCap|0);
    const step=1000/cap;
    const dt=now-last; last=now;

    if(paused){ draw(); return; }

    acc += dt;
    if(acc < step) return;
    acc = 0;

    update();
    draw();

    frames++;
    if(now - fpsLast > 700){
      fps = Math.round(frames*1000/(now-fpsLast));
      frames=0; fpsLast=now;
      fpsEl.textContent = `fps: ${fps}`;
    }
  });

  function update(){
    // camera smoothing
    yaw += (targetYaw - yaw) * 0.08;
    pitch += (targetPitch - pitch) * 0.08;

    const spMul=P.speed;
    const damp = P.lowPower ? 0.998 : 0.9992;

    const halfW=W*0.5, halfH=H*0.5, halfZ=P.depth*0.5;

    for(const p of particles){
      p.vx *= damp; p.vy *= damp; p.vz *= damp;
      p.x += p.vx*spMul;
      p.y += p.vy*spMul;
      p.z += p.vz*spMul;

      const r=p.r;
      if(p.x < -halfW+r){ p.x = -halfW+r; p.vx = Math.abs(p.vx); }
      else if(p.x > halfW-r){ p.x = halfW-r; p.vx = -Math.abs(p.vx); }
      if(p.y < -halfH+r){ p.y = -halfH+r; p.vy = Math.abs(p.vy); }
      else if(p.y > halfH-r){ p.y = halfH-r; p.vy = -Math.abs(p.vy); }
      if(p.z < -halfZ+r){ p.z = -halfZ+r; p.vz = Math.abs(p.vz); }
      else if(p.z > halfZ-r){ p.z = halfZ-r; p.vz = -Math.abs(p.vz); }

      p.linked=0;
    }

    // buckets
    clearGrid();
    for(let i=0;i<particles.length;i++){
      grid[idx3(particles[i].x, particles[i].y, particles[i].z)].push(i);
    }

    // merge/link bookkeeping (light budgets)
    const dist=P.linkDist, dist2=dist*dist;
    const mergeDist=Math.max(8, dist*0.16), mergeDist2=mergeDist*mergeDist;

    let checksBudget = P.lowPower ? Math.min(320000, particles.length*420) : 1e9;
    let merges=0;

    const toRemove=new Set();
    const toAdd=[];

    for(let i=0;i<particles.length;i++){
      if(checksBudget<=0) break;
      if(toRemove.has(i)) continue;
      const a=particles[i];

      const cx = ((a.x + W*0.5) / cell) | 0;
      const cy = ((a.y + H*0.5) / cell) | 0;
      const cz = ((a.z + P.depth*0.5) / cell) | 0;

      for(let oz=-1; oz<=1; oz++){
        const zz=cz+oz; if(zz<0||zz>=deps) continue;
        for(let oy=-1; oy<=1; oy++){
          const yy=cy+oy; if(yy<0||yy>=rows) continue;
          for(let ox=-1; ox<=1; ox++){
            const xx=cx+ox; if(xx<0||xx>=cols) continue;

            const list = grid[(zz*rows + yy)*cols + xx];
            for(let k=0;k<list.length;k++){
              const j=list[k];
              if(j<=i) continue;
              if(checksBudget--<=0) break;
              if(toRemove.has(j)) continue;

              const b=particles[j];
              const dx=b.x-a.x, dy=b.y-a.y, dz=b.z-a.z;
              const d2=dx*dx+dy*dy+dz*dz;

              // merge (close + probability)
              if(d2 < mergeDist2 && merges < 140){
                const maxC=P.maxComplex|0;
                if(a.c < maxC || b.c < maxC){
                  const cBias = 1 / (1 + 0.35*(a.c+b.c));
                  const prob = P.mergeRate * cBias;
                  if(rnd() < prob){
                    const np=new Particle(
                      (a.x+b.x)*0.5, (a.y+b.y)*0.5, (a.z+b.z)*0.5,
                      (a.vx+b.vx)*0.5 + (rnd()-0.5)*0.18,
                      (a.vy+b.vy)*0.5 + (rnd()-0.5)*0.18,
                      (a.vz+b.vz)*0.5 + (rnd()-0.5)*0.18,
                      Math.min(maxC, a.c+b.c)
                    );
                    np.r = 1.2 + Math.sqrt(np.c)*1.2;

                    toRemove.add(i); toRemove.add(j);
                    toAdd.push(np);
                    merges++;
                    break;
                  }
                }
              }

              // link counter
              const canLink = (P.maxLinks>0 && a.linked < P.maxLinks && b.linked < P.maxLinks);
              if(canLink && d2 < dist2){ a.linked++; b.linked++; }
            }
          }
        }
      }
    }

    if(toRemove.size){
      const next=[];
      for(let i=0;i<particles.length;i++) if(!toRemove.has(i)) next.push(particles[i]);
      for(const p of toAdd) next.push(p);
      particles=next;
    }
  }

  function draw(){
    // trail clear
    ctx.fillStyle = `rgba(255,255,255,${0.08 + 0.06*P.trail})`;
    ctx.fillRect(0,0,W,H);

    // project
    const halfW=W*0.5, halfH=H*0.5;
    const proj = new Array(particles.length);
    for(let i=0;i<particles.length;i++){
      const p=particles[i];

      let rx=p.x, ry=p.y, rz=p.z;
      const ryaw = rotY(rx, rz, yaw); rx=ryaw.x; rz=ryaw.z;
      const rpitch = rotX(ry, rz, pitch); ry=rpitch.y; rz=rpitch.z;

      const zCam = rz + P.depth*0.75;
      const scale = P.fov / Math.max(50, zCam);
      proj[i] = { i, sx: rx*scale + halfW, sy: ry*scale + halfH, zCam, scale };
    }

    // rebuild buckets for links (reuse original positions)
    clearGrid();
    for(let i=0;i<particles.length;i++){
      const p=particles[i];
      grid[idx3(p.x,p.y,p.z)].push(i);
    }

    // links budget
    const dist=P.linkDist, dist2=dist*dist;
    let linkBudget = P.lowPower ? Math.min(16000, particles.length*14) : 38000;

    // brand-ish color
    const base = {r:27,g:116,b:181}; // tuned to the blue vibe

    for(let i=0;i<particles.length;i++){
      if(linkBudget<=0) break;
      const a=particles[i];
      const pa=proj[i];

      const cx = ((a.x + W*0.5) / cell) | 0;
      const cy = ((a.y + H*0.5) / cell) | 0;
      const cz = ((a.z + P.depth*0.5) / cell) | 0;

      for(let oz=-1; oz<=1; oz++){
        const zz=cz+oz; if(zz<0||zz>=deps) continue;
        for(let oy=-1; oy<=1; oy++){
          const yy=cy+oy; if(yy<0||yy>=rows) continue;
          for(let ox=-1; ox<=1; ox++){
            const xx=cx+ox; if(xx<0||xx>=cols) continue;

            const list = grid[(zz*rows + yy)*cols + xx];
            for(let k=0;k<list.length;k++){
              const j=list[k];
              if(j<=i) continue;

              const b=particles[j];
              const dx=b.x-a.x, dy=b.y-a.y, dz=b.z-a.z;
              const d2=dx*dx+dy*dy+dz*dz;

              if(d2 < dist2){
                if(linkBudget--<=0) break;

                const pb=proj[j];
                const d=Math.sqrt(d2);
                const t=1-(d/dist);

                const depthFade = Math.max(0.15, Math.min(1, 900/(0.5*(pa.zCam+pb.zCam))));
                const alpha = (0.06 + 0.24*t) * (0.55 + 0.45*P.trail) * depthFade;

                ctx.strokeStyle = `rgba(${base.r},${base.g},${base.b},${alpha})`;
                ctx.beginPath();
                ctx.moveTo(pa.sx, pa.sy);
                ctx.lineTo(pb.sx, pb.sy);
                ctx.stroke();
              }
            }
          }
        }
      }
    }

    // particles back-to-front
    proj.sort((a,b)=> b.zCam - a.zCam);

    for(const pr of proj){
      const p=particles[pr.i];
      const radius = p.r * pr.scale * 1.2;
      if(radius < 0.15) continue;

      const cT = (p.c-1)/Math.max(1,(P.maxComplex-1));
      const alpha = (0.35 + 0.35*P.trail) * Math.max(0.15, Math.min(1, 900/pr.zCam));

      const rr = Math.round( mix(base.r, 255, 0.10 + 0.30*cT) );
      const gg = Math.round( mix(base.g, 255, 0.08 + 0.18*cT) );
      const bb = Math.round( mix(base.b, 255, 0.10 + 0.28*cT) );

      ctx.fillStyle = `rgba(${rr},${gg},${bb},${alpha})`;
      ctx.beginPath();
      ctx.arc(pr.sx, pr.sy, radius, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // tiny helper
  function mix(a,b,t){ return a+(b-a)*t; }
})();
</script>
</body>
</html>
